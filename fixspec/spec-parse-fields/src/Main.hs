-- Copyright James D. Brock (c) 2018
--
-- Boost Software License - Version 1.0 - August 17th, 2003
-- See accompanying file LICENSE

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE RecordWildCards #-}

module Main where

import Data.Function
import Data.Maybe
import Data.Monoid
import Data.Either
import Data.List
import Data.Foldable
import Data.Traversable
import Control.Monad
import Data.Default.Class -- xml-conduit requires this :(
import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import qualified Data.Text.Lazy as T
import qualified Data.Text as T.Strict
import Data.Text.Lazy (Text)
import qualified Data.Text.Lazy.IO as T
import Data.Text.Lazy.Builder (toLazyText, fromText, fromLazyText)
import Data.Text.Lazy.Builder.Int (decimal)
import Data.Text.Format as T (right)
import qualified Data.Text.Read as T.Read
import qualified Text.XML as XML
import Text.XML.Cursor as XML

import Data.XML.DTD.Types
import Data.XML.DTD.Parse

main = do

    -- Step 1. Read and parse the spec files

    fix43dtd <- parseDTD <$> T.readFile "fix.4.3/fixml4.3v20020920.dtd"
    fix44dtd <- parseDTD <$> T.readFile "fix.4.4/FIXML4.4v20030618.dtd"
    fix50schema <- XML.readFile def "fix.5.0.sp2/fixmlschema/fixml-fields-base-5-0-SP2.xsd"

    let foldFields43 :: Fields -> Fields
        foldFields43 f = foldl' (flip addField43) f $ dtdComponents fix43dtd
    let foldFields44 :: Fields -> Fields
        foldFields44 f = foldl' (flip addField44) f $ dtdComponents fix44dtd
    let foldFields50 :: Fields -> Fields
        foldFields50 f = foldl' (flip addField50) f $ fmap XML.node $
            XML.fromDocument fix50schema XML.$| anyElement XML.&/
            laxElement "simpleType" XML.&/ anyElement XML.&/
            laxElement "appinfo" XML.&/ laxElement "Xref"

    -- All the FIX fields collected from all FIX versions.
    let fields = foldFields50 $ foldFields44 $ foldFields43 extraFields

    -- All the FIX Message Types from FIX 5.0.
    let msgTypeElements = fmap node $ XML.fromDocument fix50schema XML.$|
            anyElement
            XML.&/ laxElement "simpleType"
            >=> XML.attributeIs (mkAttName "name") "MsgType_enum_t"
            XML.&/ anyElement
            XML.&/ laxElement "appinfo"
            XML.&/ laxElement "EnumDoc"

    -- Step 2. Write hffix_fields.hpp to stdout.

    T.putStr $ T.unlines
        [ "/*!"
        , "\\file"
        , "\\brief The hffix_fields.hpp file is generated by the spec/spec-parse-fields Haskell program from the FIX Protocol specification documents in the spec/ directory."
        , ""
        , "Do not edit this file, instead modify the spec/spec-parse-fields program and run it from the spec/spec-parse-fields directory as shown here. You must have The Haskell Tool Stack https://haskellstack.org installed."
        , ""
        , "    hffix/spec/spec-parse-fields$ stack run --cwd .. > ../../include/hffix_fields.hpp"
        , ""
        , "Line comments for each field indicate the data type of the field for each version of the FIX spec in which the field appears."
        , "*/"
        , ""
        , "#ifndef HFFIX_FIELDS_HEADER"
        , "#define HFFIX_FIELDS_HEADER"
        , "namespace hffix {"
        , ""
        , "/*!"
        , "\\brief Namespace for all field tag name enums."
        , "*/"
        , "namespace tag {"
        , "enum {"
        ]

    -- Write C++ enum of all field tags.
    forM_ (markbounds $ Map.toAscList fields) $ \((ftag, fs), _, isLast) ->
        case fs of
            f1@(Field fname  _  _):_ -> do
                let tagBldr =
                        T.right 50 ' ' fname <> fromText " = " <>
                        decimal ftag <>
                        (if isLast then mempty else fromText ",") <>
                        fromText " //!< " <>
                        decimal ftag <> fromText " "

                    versionRender (Field _ ftype fversion) =
                        fromText "(" <> fromText ftype <>
                        fromText " " <> fromText fversion <>
                        fromText ")"
                    versionBldr = fold $ intersperse (fromText " ") $
                        fmap versionRender fs

                    sameNameType (Field fname1 ftype1 _) (Field fname2 ftype2 _)
                        = (fname1 == fname2) && (ftype1 == ftype2)
                    -- If the different spec versions have a different data
                    -- type or different name for this field tag number,
                    -- then print *Different*.
                    diffBldr = if all (sameNameType f1) fs
                        then mempty else fromText " *Different*"

                T.putStrLn $ toLazyText $ tagBldr <> versionBldr <> diffBldr

            _ -> return ()

    T.putStr $ T.unlines
        [ "};"
        , "} // namespace tag"
        , ""
        , "namespace {"
        , "//! Sorted list of all field tags which are of type Length"
        , "int length_fields[] = {"
        ]

    -- Write C++ array of all field tags for fields of type Length.
    let lengthFields = (Map.filter (any ((== "Length") . ftype))) fields

    forM_ (markbounds $ Map.toAscList lengthFields) $ \((ftag, fs), _, isLast) ->
        case fs of
            (Field fname "Length" fversion:_) -> do
                T.putStrLn $ toLazyText $
                    T.right 35 ' ' (fromText "tag::" <> fromText fname <>
                    fromText (if isLast then "" else ",")) <>
                    fromText " // " <> decimal ftag <> fromText " " <>
                    fromText "Length" <> fromText " " <> fromText fversion
            _ -> return ()

    T.putStr $ T.unlines
        [ "};"
        , "}"
        , ""
        , "/*!"
        , " * \\brief Populate an AssociativeContainer with the names of all the FIX fields."
        , " *"
        , " * \\param dictionary A reference to an AssociativeContainer<int, std::string>"
        , " */"
        , " template <typename AssociativeContainer> void dictionary_init_field(AssociativeContainer& dictionary) {"
        ]

    -- Write C++ init method for a associative container for run-time field tag lookup.
    forM_ (Map.toAscList fields) $ \(ftag, fs) ->
        case fs of
            f1@(Field fname  _  _):_ -> do
                let tagBldr =
                        T.right 50 ' ' (fromText "dictionary[tag::" <>
                                        fromText fname <> fromText "]") <>
                        fromText " = " <>
                        T.right 50 ' ' (fromText "\"" <> fromText fname <>
                                        fromText "\";") <>
                        fromText " // "

                    versionRender (Field _ ftype fversion) =
                        fromText "(" <> fromText ftype <>
                        fromText " " <> fromText fversion <>
                        fromText ")"
                    versionBldr = fold $ intersperse (fromText " ") $
                        fmap versionRender fs

                    sameNameType (Field fname1 ftype1 _) (Field fname2 ftype2 _)
                        = (fname1 == fname2) && (ftype1 == ftype2)
                    -- If the different spec versions have a different data
                    -- type or different name for this field tag number,
                    -- then print *Different*.
                    diffBldr = if all (sameNameType f1) fs
                        then mempty else fromText " *Different*"

                T.putStrLn $ toLazyText $ tagBldr <> versionBldr <> diffBldr

    -- Write C++ init method for a associative container for run-time message name lookup.
    T.putStr $ T.unlines
        [ "}"
        , "/*!"
        , " * \\brief Populate an AssociativeContainer with the names of all the FIX message types."
        , " *"
        , " * \\param dictionary A reference to an AssociativeContainer<std::string, std::string>"
        , " */"
        , " template <typename AssociativeContainer> void dictionary_init_message(AssociativeContainer& dictionary) {"
        ]

    forM_ (mapMaybe mkMsgType50 msgTypeElements) $ \MsgType{..} -> do
        let msgBldr =
                T.right 25 ' ' (fromText "dictionary[\"" <>
                                fromText mvalue <> fromText "\"]") <>
                fromText " = " <>
                T.right 40 ' ' (fromText "\"" <> fromText mname <>
                                fromText "\";") <>
                fromText " //" <>
                fromText " (" <> fromText mversion <> fromText ")"
        T.putStrLn $ toLazyText msgBldr

    T.putStr $ T.unlines
        [ "}"
        , "} // namespace hffix"
        , "#endif // HFFIX_FIELDS_HEADER"
        ]





-- Data Structures
-- ===============

-- One FIX field for one version of the FIX spec
data Field = Field { fname    :: T.Strict.Text -- FIX field name
                   , ftype    :: T.Strict.Text -- FIX field type
                   , fversion :: T.Strict.Text -- FIX field version
                   }
  deriving (Show, Eq)

-- Map of FIX tag to all of the fields names for each version of FIX
type Fields = Map Int [Field]

-- One Message Type for one version of the FIX spec
data MsgType = MsgType { mname    :: T.Strict.Text -- MessageType name
                       , mvalue   :: T.Strict.Text -- MessageType field value
                       , mversion :: T.Strict.Text -- MessageType version
                       }





-- Parsing Functions
-- =================

-- Read the FIX field information out of one FIX 4.3 DTD entry and add it to
-- a Fields Map.
-- Use the <!ATTLIST> elements where the FIX type is "Length", ignore
-- anything else, because parsing is too difficult.
addField43 :: DTDComponent -> Fields -> Fields
addField43 (DTDAttList
                    (AttList fname
                        ((AttDecl "FIXTag" AttStringType (AttFixed ftagText))
                        :(AttDecl "DataType" AttStringType (AttFixed "Length")):_)
                    )
                  ) =
    case T.Read.decimal ftagText of
        Left _ -> id
        Right (ftag, _) ->
            Map.insertWith mappend ftag [Field fname "Length" "4.3"]
addField43 _ = id


-- Read the FIX field information out of one FIX 4.4 DTD entry and add it to
-- a Fields Map.
addField44 :: DTDComponent -> Fields -> Fields
addField44 c = case c of
    (DTDAttList
        (AttList _
            ((AttDecl "FIXTag" AttStringType (AttFixed ftagText))
            :(AttDecl "DataType" AttStringType (AttFixed ftype))
            :(AttDecl "FullName" AttStringType (AttFixed fname))
            :(AttDecl "ComponentType" AttStringType (AttFixed "Field"))
            :_)
        )
      ) -> insertWith ftagText fname ftype
    (DTDAttList
        (AttList _
            ((AttDecl "NumInGrp_FIELD" AttStringType (AttFixed fname))
            :(AttDecl "FIXTag" AttStringType (AttFixed ftagText))
            :(AttDecl "ComponentType" AttStringType (AttFixed "BlockRepeating"))
            :_)
        )
      ) -> insertWith ftagText fname "BlockRepeating"
    (DTDAttList
        (AttList _
            ((AttDecl "FullName" AttStringType _)
            :(AttDecl "NumInGrp_FIELD" AttStringType (AttFixed fname))
            :(AttDecl "FIXTag" AttStringType (AttFixed ftagText))
            :(AttDecl "ComponentType" AttStringType (AttFixed "BlockRepeating"))
            :_)
        )
      ) -> insertWith ftagText fname "BlockRepeating"
    _   -> id
  where
    insertWith ftagText fname ftype =
        case T.Read.decimal ftagText of
            Left _ -> id
            Right (ftag, _) ->
                Map.insertWith union ftag [Field fname (substType ftype) "4.4"]
    substType "month-year" = "MonthYear"
    substType "int " = "int"
    substType x = x


-- Read the FIX field information out of one FIX 5.0 schema entry and add it to
-- a Fields Map.
addField50 :: XML.Node -> Fields -> Fields
addField50 (XML.NodeElement XML.Element{XML.elementAttributes = atts}) =
    maybe id insertWith $ do
        -- require that these attributes have these values
        mfilter ("Field"==) $ Map.lookup (mkAttName "ComponentType") atts
        mfilter ("FIX"==) $ Map.lookup (mkAttName "Protocol") atts

        ftagText <- Map.lookup (mkAttName "Tag") atts
        ftype    <- Map.lookup (mkAttName "Type") atts
        fname    <- Map.lookup (mkAttName "name") atts
        return (ftagText, fname, ftype)
  where
    insertWith (ftagText, fname, ftype) =
        case T.Read.decimal ftagText of
            Left _ -> id
            Right (ftag, _) ->
                Map.insertWith mappend ftag [Field fname ftype "5.0.SP2"]
addField50 _ = id


-- Add some fields from 4.2 which don't get included by the spec parsing for
-- any of the other versions.
extraFields :: Fields
extraFields = Map.fromList
    [ (7   , [Field "BeginSeqNo"             "int"          "4.2"])
    , (16  , [Field "EndSeqNo"               "int"          "4.2"])
    , (36  , [Field "NewSeqNo"               "int"          "4.2"])
    , (90  , [Field "SecureDataLen"          "Length"       "4.2"])
    , (91  , [Field "SecureData"             "data"         "4.2"])
    , (98  , [Field "EncryptMethod"          "int"          "4.2"])
    , (108 , [Field "HeartBtInt"             "int"          "4.2"])
    , (112 , [Field "TestReqID"              "String"       "4.2"])
    , (123 , [Field "GapFillFlag"            "Boolean"      "4.2"])
    , (141 , [Field "ResetSeqNumFlag"        "Boolean"      "4.2"])
    , (212 , [Field "XmlDataLen"             "Length"       "4.2"])
    , (213 , [Field "XmlData"                "data"         "4.2"])
    , (369 , [Field "LastMsgSeqNumProcessed" "int"          "4.2"])
    , (370 , [Field "OnBehalfOfSendingTime"  "UTCTimeStamp" "4.2"])
    , (373 , [Field "SessionRejectReason"    "int"          "4.2"])
    , (383 , [Field "MaxMessageSize"         "int"          "4.2"])
    ]


-- Make a MsgType from a FIX 5.0 schema entry.
mkMsgType50 :: XML.Node -> Maybe MsgType
mkMsgType50 (XML.NodeElement XML.Element
                { XML.elementAttributes = atts
                , XML.elementNodes = (XML.NodeContent mname:_)}) = do
    mvalue <- Map.lookup (mkAttName "value") atts
    let mversion = "5.0.SP2"
    return $ MsgType {..}
mkMsgType50 _ = Nothing


-- Make an XML attribute name.
mkAttName n = XML.Name
            { XML.nameLocalName = n
            , XML.nameNamespace = Nothing
            , XML.namePrefix = Nothing
            }


-- | Annotate elements of a list with Bools, the first of which is True if
-- the element is the head of the list, the second of which is True if the
-- element is the last of the list. Both are True for singleton.
markbounds :: [a] -> [(a, Bool, Bool)]
markbounds [] = []
markbounds [x] = [(x, True, True)]
markbounds (x:xs) = (x, True, False) : tailbound xs
  where
    tailbound [y] = [(y, False, True)]
    tailbound (y:ys) = (y, False, False): tailbound ys

