#!/usr/bin/python

import sys
import re
import operator

fix43dtd = 'fix.4.3/fixml4.3v20020920.dtd'
fix44dtd = 'fix.4.4/FIXML4.4v20030618.dtd'
fix50schema = 'fix.5.0.sp2/fixmlschema/fixml-fields-base-5-0-SP2.xsd'

# fields is a dictionary such that
#     Key is an integer Tag
#     Value is a list of tuples representing FIX fields in the form [(Fieldname, Type, Version)]
fields = {}

# Parse FIX 5.0 Schema.
pattern50sp2 = """<fm:Xref +Protocol="FIX" +name="(\w+)"[^>]*?Tag="(\d+)"[^>]*?Type="(\w+)"[^>]*?/>"""
for m in re.compile(pattern50sp2, re.MULTILINE | re.DOTALL).finditer(open(fix50schema, 'r').read()):
  fields.setdefault(int(m.group(2)), []).append(m.group(1, 3) + ("5.0.SP2",))

# Parse FIX 4.4 DTD.
pattern44 = """<!ATTLIST[^>]*?FIXTag[^>]*?'(\d+)'[^>]*?DataType[^>]*?'(\w+?)'[^>]*?FullName[^>]*?'(\w+?)'[^>]*?ComponentType CDATA #FIXED 'Field'[^>]*?>"""
for m in re.compile(pattern44, re.MULTILINE | re.DOTALL).finditer(open(fix44dtd, 'r').read()):
  fields.setdefault(int(m.group(1)), []).append(m.group(3, 2) + ("4.4",))

# Parse FIX 4.3 DTD. Only the fields of type Length, because the dtd fields can't be parsed by regex.
pattern43 = """<!ATTLIST +(\w+)[^>]*?FIXTag[^>]*?['"](\d+)['"][^>]*?DataType[^>]*?['"](Length)['"][^>]*?>"""
for m in re.compile(pattern43, re.MULTILINE | re.DOTALL).finditer(open(fix43dtd, 'r').read()):
  fields.setdefault(int(m.group(2)), []).append(m.group(1, 3) + ("4.3",))


sys.stdout.write ("""// The hffix_fields.hpp file is generated by the spec/codegen python program
// from the FIX Protocol specifications documents in the spec directory.
// Do not edit this file, all edits will be overwritten the next time spec/codegen is run.

#ifndef HFFIX_FIELDS_HEADER
#define HFFIX_FIELDS_HEADER
""")

sys.stdout.write("namespace hffix {\nnamespace tag {\n");
# Write C++ enum of all field tags.
sys.stdout.write("enum {\n")
l = sorted(fields.iteritems(), operator.lt, operator.itemgetter(0))
for i in l:
  sys.stdout.write("{:<50} = {}".format(i[1][0][0], i[0]))
  if i[0] != l[-1][0]: sys.stdout.write(",")
  sys.stdout.write(" //")
  for field in i[1]: sys.stdout.write(" (" + field[1] + " " + field[2] + ")")
  if reduce(lambda x, y: x or (y[0] != i[1][0][0]) or (y[1] != i[1][0][1]), i[1], False): sys.stdout.write(" *Different*") # If the different spec versions have a different data type or different name for this field tag number, then print *Different*.
  sys.stdout.write("\n")
sys.stdout.write("};\n")
sys.stdout.write("} // namespace tag\n")

# Write C++ array of all field tags for fields of type Length.
sys.stdout.write("int length_fields[] = {\n")
l = sorted(filter(lambda x: any(map(lambda y: y[1] == "Length", x[1])), fields.iteritems()), operator.lt, operator.itemgetter(0))
for i in l:
  # sys.stdout.write(i[1][0][0])
  sys.stdout.write("{:<35}".format("tag::" + i[1][0][0] + ("" if i[0] == l[-1][0] else ",")))
  # if i[0] != l[-1][0]: sys.stdout.write(",")
  sys.stdout.write(" // " + str(i[0]) + " " + i[1][0][1] + " " + i[1][0][2])
  sys.stdout.write("\n")
sys.stdout.write("};\n")

# Write C++ init method for a associative container for run-time field tag lookup.
sys.stdout.write("template <typename AssociativeContainer> void field_dictionary_init(AssociativeContainer& dictionary) {\n")
l = sorted(fields.iteritems(), operator.lt, operator.itemgetter(0))
for i in l:
  sys.stdout.write("{:<50} = {:<50}".format("dictionary[tag::" + i[1][0][0] + "]", '"' + i[1][0][0] + '";'))
  sys.stdout.write(" //")
  for field in i[1]: sys.stdout.write(" (" + field[1] + " " + field[2] + ")")
  if reduce(lambda x, y: x or (y[0] != i[1][0][0]) or (y[1] != i[1][0][1]), i[1], False): sys.stdout.write(" *Different*") # If the different spec versions have a different data type or different name for this field tag number, then print *Different*.
  sys.stdout.write("\n")
sys.stdout.write("}\n")

sys.stdout.write("""} // namespace hffix
#endif // HFFIX_FIELDS_HEADER
""")

